<!-- =========================================================================
File: pool_dashboard.html
Location: snap-coin-pool/static/pool_dashboard.html
Version: 1.6.0-dual-hashrate.1

Changes from v1.5.5-compact.15:
  - KPI: Replace "POOL HASHRATE" with "POOL EFFICIENCY" (acc/(acc+rej) %).
  - NEW: Metrics row between blocks chart and hashrate chart:
      * Pool Hashrate (green pill)
      * Network Hashrate (cyan pill)
      * Pool/Network share % (purple pill)
  - Hashrate chart: Dual-axis overlay:
      * Pool hashrate: solid green line, left Y-axis (green ticks)
      * Network hashrate: dashed cyan line, right Y-axis (cyan ticks)
      * Independent scales so 1000x gap renders correctly
      * Legend + inline metric pills in chart header
  - Data: Load snapshot.timeseries.network_hashrate_1m_24h into state.netHrSeries.
  - No other layout/logic changes.
========================================================================  -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Snap Coin Pool — Dashboard</title>

  <style>
    :root{
      --bg: #070a0f;
      --panel: rgba(255,255,255,0.04);
      --panel2: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.62);

      --green: #8cdaae;
      --cyan: #6fe7ff;
      --yellow: #ffe066;
      --red: #ff5c7a;
      --orange: #ffb86b;
      --purple: #c4b5fd;

      /* magenta for miner-paid feed lines */
      --magenta: #ff63d8;

      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(76,255,155,0.14), transparent 60%),
        radial-gradient(900px 500px at 90% 0%, rgba(111,231,255,0.12), transparent 55%),
        radial-gradient(900px 500px at 70% 120%, rgba(255,224,102,0.08), transparent 60%),
        var(--bg);
      color: var(--text);
      font-family: var(--sans);
      height: 100vh;
      overflow: hidden;
    }

    .wrap{
      max-width: 1920px;
      margin: 0 auto;
      padding: 14px 18px 16px 18px;
      height: 100vh;
      overflow: hidden;
      display:flex;
      flex-direction:column;
    }

    .statuswrap{
      display:flex;
      align-items:center;
      gap: 12px;
      flex: 0 0 auto;
      flex-wrap: wrap;
      justify-content: flex-end;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
    }

    .statusline{
      display:flex;
      align-items:center;
      gap: 10px;
      white-space: nowrap;
    }

    .dot{
      width:10px; height:10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
      box-shadow: 0 0 0 4px rgba(255,255,255,0.04);
      flex: 0 0 auto;
    }
    .dot.ok{ background: var(--green); box-shadow: 0 0 0 4px rgba(76,255,155,0.12); }
    .dot.bad{ background: var(--red); box-shadow: 0 0 0 4px rgba(255,92,122,0.12); }

    .statuskv .k{ color: rgba(255,255,255,0.45); margin-right: 6px; }
    .statuskv .v{ color: rgba(255,255,255,0.90); font-weight: 800; }

    .grid{
      display:grid;
      grid-template-columns: 1.35fr 0.95fr;
      gap: 18px;
      flex: 1 1 auto;
      min-height: 0;
    }

    .card{
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 0;
    }

    .head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent);
      gap: 10px;
    }

    .head h2{
      margin:0;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    .hint{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    .body{
      padding: 16px;
      min-height: 0;
    }

    .kpis{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }

    .kpi{
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px 12px;
      min-height: 86px;

      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap: 6px;
    }

    .label{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin: 0;
    }

    .value{
      font-family: var(--mono);
      font-size: 18px;
      font-weight: 900;
      letter-spacing: 0.2px;
      margin: 0;
    }

    .sub{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(255,255,255,0.55);
      margin: 0;
    }

    .accent-green{ color: var(--green); }
    .accent-cyan{ color: var(--cyan); }
    .accent-yellow{ color: var(--yellow); }
    .accent-red{ color: var(--red); }
    .accent-orange{ color: var(--orange); }
    .accent-magenta{ color: var(--magenta); }
    .accent-purple{ color: var(--purple); }

    .row1{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .panel{
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px;
    }

    .rows .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .rows .row:last-child{ border-bottom:none; }

    .left{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,0.72);
    }

    .right{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      text-align:right;
    }

    .fullrow{
      margin-top: 12px;
    }

    .chart-wrap{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.06);
    }
    .chart-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .chart-left{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .chart-title{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(255,255,255,0.70);
    }
    .chart-controls{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .chip:hover{ background: rgba(255,255,255,0.06); }
    .chip.on{
      border-color: rgba(111,231,255,0.35);
      background: rgba(111,231,255,0.10);
      color: rgba(255,255,255,0.92);
      font-weight: 800;
    }

    /* ── Hashrate chart legend ── */
    .legend{
      display: flex;
      gap: 12px;
    }
    .legend-item{
      display: flex;
      align-items: center;
      gap: 5px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
    }
    .legend-dot{
      width: 8px; height: 8px;
      border-radius: 50%;
    }
    .legend-dot.pool{ background: var(--green); }
    .legend-dot.net{ background: var(--cyan); }

    /* ── Inline metric pills ── */
    .inline-metrics{
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .metric{
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 4px 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      font-family: var(--mono);
      font-size: 11px;
      white-space: nowrap;
    }
    .metric .m-label{
      color: rgba(255,255,255,0.40);
      font-size: 10px;
    }
    .metric .m-val{
      font-weight: 800;
    }
    .metric.pool .m-val{ color: var(--green); }
    .metric.net .m-val{ color: var(--cyan); }
    .metric.pct .m-val{ color: var(--purple); }

    canvas{
      width: 100%;
      height: 74px;
      display:block;
      border-radius: 12px;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.10);
    }

    #blocks-chart{ height: 95px; }
    #hashrate-chart{ height: 170px; }

    .controls{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin-bottom: 12px;
    }

    input[type="text"]{
      flex: 1;
      min-width: 240px;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.26);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      outline: none;
    }

    input[type="text"]::placeholder{ color: rgba(255,255,255,0.35); }

    button{
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      cursor:pointer;
    }
    button:hover{ background: rgba(255,255,255,0.09); }
    button:active{ transform: translateY(1px); }

    .muted{
      color: var(--muted);
      font-family: var(--mono);
      font-size: 11px;
      line-height: 1.45;
    }

    .mini-table{
      width:100%;
      border-collapse: collapse;
      font-family: var(--mono);
      font-size: 12px;
    }
    .mini-table td{
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      vertical-align: top;
    }
    .mini-table tr:last-child td{ border-bottom: none; }
    .mini-table td:first-child{
      color: rgba(255,255,255,0.62);
      width: 5%;
      padding-right: 12px;
    }
    .mini-table td:last-child{
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      text-align: right;
      word-break: break-all;
    }

    .picker{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 10px;
    }

    .rightcol{
      display:flex;
      flex-direction:column;
      gap: 18px;
      height: 100%;
      min-height: 0;
    }

    #miner-card{ flex: 0 0 auto; flex-shrink: 0; }

    .feed{
      height: 100%;
      overflow:auto;
      padding-right: 6px;
    }

    .evt{
      border-left: 3px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      padding: 10px 10px;
      margin-bottom: 10px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }

    .evt .t{ color: rgba(255,255,255,0.50); margin-right: 8px; }
    .evt .tag{ font-weight: 900; }

    .evt.share{ border-left-color: var(--green); }
    .evt.reject{ border-left-color: var(--red); }
    .evt.block{ border-left-color: var(--yellow); }
    .evt.payout{ border-left-color: var(--cyan); }
    .evt.miner{ border-left-color: rgba(255,255,255,0.35); }
    .evt.minerpay{ border-left-color: var(--magenta); }

    .collapse-btn{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      cursor:pointer;
      user-select:none;
      white-space: nowrap;
    }
    .collapse-btn:hover{ background: rgba(255,255,255,0.06); }

    .card.collapsed .body{ display:none; }
    .card.collapsed{ flex: 0 0 auto; }
    .card.collapsed .head{ border-bottom: none; }

    #feed-card{
      flex: 1 1 auto;
      min-height: 0;
    }
    #feed-card .body{
      height: 100%;
      min-height: 0;
      display:flex;
      flex-direction:column;
    }
    #feed{
      flex: 1 1 auto;
      min-height: 0;
    }

    a.explink{
      color: var(--muted);
      text-decoration: none;
      cursor: pointer;
      padding: 0 2px;
      border-radius: 4px;
      transition: color 0.12s ease, background 0.12s ease;
    }
    a.explink:hover{
      color: rgb(187, 134, 65);
      background: rgba(255,255,255,0.08);
    }

    .minerlink{
      cursor: pointer;
      padding: 0 2px;
      border-radius: 4px;
      transition: color 0.12s ease, background 0.12s ease;
      user-select: text;
    }
    .minerlink:hover{
      color: var(--orange);
      background: rgba(255,255,255,0.08);
    }

    @media (max-width: 1100px){
      body{ overflow:auto; height:auto; }
      .wrap{ height:auto; overflow:visible; }
      .grid{ grid-template-columns: 1fr; min-height: unset; }
      .kpis{ grid-template-columns: repeat(2, 1fr); }
      .row1{ grid-template-columns: 1fr; }
      .rightcol{ height:auto; }
      #feed-card{ min-height: 420px; }
      .statuswrap{ justify-content: flex-start; }
      .inline-metrics{ flex-wrap: wrap; }
    }

    ::-webkit-scrollbar { width: 10px; height:10px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.25); border-radius: 10px; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.14); border-radius: 10px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.20); }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="grid">

      <!-- LEFT: Overview -->
      <div class="card">
        <div class="head">
          <div style="display:flex;align-items:center;gap:8px;">
            <img src="https://faucet.snap-coin.net/logo.svg" alt="Snap Coin" width="28" height="28" style="flex:0 0 auto;"/>
            <h2 style="margin:0;font-size:14px;font-weight:800;letter-spacing:0.2px;">Snap Coin Pool <span style="font-weight:400;color:rgba(255,255,255,0.45);">Protocol V2</span></h2>
          </div>

          <div class="statuswrap" title="WebSocket connection status">
            <div class="statusline">
              <span id="status-dot" class="dot"></span>
              <span id="status-text">Connecting…</span>
              <span class="statuskv">
                <span class="k">last_evt:</span><span id="last-evt" class="v">—</span>
              </span>
            </div>
          </div>
        </div>

        <div class="body">
          <div class="kpis">
            <div class="kpi">
              <div class="label">ACTIVE MINERS</div>
              <div id="kpi-miners" class="value accent-cyan">0</div>
            </div>

            <div class="kpi">
              <div class="label">POOL EFFICIENCY</div>
              <div id="kpi-eff" class="value accent-green">—</div>
            </div>

            <div class="kpi">
              <div class="label">SHARES (ACC / REJ)</div>
              <div class="value">
                <span id="kpi-acc" class="accent-green">0</span>
                <span style="color:rgba(255,255,255,0.35)">/</span>
                <span id="kpi-rej" class="accent-red">0</span>
              </div>
            </div>

            <div class="kpi">
              <div class="label">BLOCKS FOUND</div>
              <div id="kpi-blocks" class="value accent-yellow">0</div>
            </div>
          </div>

          <div class="row1">
            <div class="panel">
              <div class="label">Network Health</div>
              <div class="rows">
                <div class="row">
                  <div class="left">network_height</div>
                  <div class="right" id="net-height">—</div>
                </div>
                <div class="row">
                  <div class="left">network_hashrate</div>
                  <div class="right" id="net-hashrate">—</div>
                </div>
                <div class="row">
                  <div class="left">network_difficulty</div>
                  <div class="right" id="net-difficulty">—</div>
                </div>
                <div class="row">
                  <div class="left">block_reward</div>
                  <div class="right" id="net-reward">—</div>
                </div>
                <div class="row">
                  <div class="left">last_block_age</div>
                  <div class="right" id="net-last-age">—</div>
                </div>
                <div class="row">
                  <div class="left">avg_block_time</div>
                  <div class="right" id="net-avg-bt">—</div>
                </div>
                <div class="row">
                  <div class="left">last_hash</div>
                  <div class="right" id="net-last-hash">—</div>
                </div>
              </div>
            </div>

            <div class="panel">
              <div class="label">Pool Payout Summary</div>
              <div class="rows">
                <div class="row">
                  <div class="left">last_payout_height</div>
                  <div class="right" id="snap-last-payout">—</div>
                </div>
                <div class="row">
                  <div class="left">Total reward</div>
                  <div class="right" id="snap-last-payout-total">—</div>
                </div>
                <div class="row">
                  <div class="left">Miners reward (net)</div>
                  <div class="right" id="snap-last-payout-net">—</div>
                </div>
                <div class="row">
                  <div class="left">Pool fee</div>
                  <div class="right" id="snap-last-payout-fee">—</div>
                </div>
                <div class="row">
                  <div class="left">Miners paid (count)</div>
                  <div class="right" id="snap-last-payout-miners">—</div>
                </div>
                <div class="row">
                  <div class="left">Total paid to miners</div>
                  <div class="right" id="snap-total-paid-miners">—</div>
                </div>
                <div class="row">
                  <div class="left">Pool difficulty (fixed)</div>
                  <div class="right" id="snap-pool-diff-fixed">—</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Blocks chart -->
          <div class="fullrow">
            <div class="panel">
              <div class="chart-wrap">
                <div class="chart-head">
                  <div class="chart-title" id="blocks-chart-title">Blocks per day</div>
                  <div class="chart-controls">
                    <div id="blocks-1d" class="chip">1d</div>
                    <div id="blocks-7d" class="chip on">7d</div>
                    <div id="blocks-30d" class="chip">30d</div>
                  </div>
                </div>
                <canvas id="blocks-chart" width="1200" height="260"></canvas>
              </div>
            </div>
          </div>

          <!-- Hashrate chart (dual axis) -->
          <div class="fullrow">
            <div class="panel">
              <div class="chart-wrap">
                <div class="chart-head">
                  <div class="chart-left">
                    <div class="chart-title" id="hr-chart-title">Hashrate (last 6h)</div>
                    <div class="legend">
                      <div class="legend-item"><span class="legend-dot pool"></span>Pool</div>
                      <div class="legend-item"><span class="legend-dot net"></span>Network</div>
                    </div>
                    <div class="inline-metrics">
                      <div class="metric pool">
                        <span class="m-label">pool</span>
                        <span class="m-val" id="m-pool-hr">—</span>
                      </div>
                      <div class="metric net">
                        <span class="m-label">net</span>
                        <span class="m-val" id="m-net-hr">—</span>
                      </div>
                      <div class="metric pct">
                        <span class="m-label">share</span>
                        <span class="m-val" id="m-share-pct">—</span>
                      </div>
                    </div>
                  </div>
                  <div class="chart-controls">
                    <div id="hr-1h" class="chip">1h</div>
                    <div id="hr-6h" class="chip on">6h</div>
                    <div id="hr-24h" class="chip">24h</div>
                  </div>
                </div>
                <canvas id="hashrate-chart" width="1200" height="420"></canvas>
                <div style="margin-top:6px;display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;font-family:var(--mono);font-size:10px;color:rgba(255,255,255,0.30);">
                  <span>built by <a href="https://github.com/OIEIEIO/snap-coin-pool/tree/new-protocol-dash" target="_blank" rel="noopener" style="color:rgba(255,255,255,0.45);text-decoration:none;">OIEIEIO</a> · <a href="https://github.com/OIEIEIO/snap-coin-pool/tree/new-protocol-dash" target="_blank" rel="noopener" style="color:rgba(255,255,255,0.45);text-decoration:none;">github</a></span>
                  <span style="display:flex;align-items:center;gap:6px;">
                    <span>donate SNAP:</span>
                    <span id="donate-addy" style="color:var(--orange);font-weight:700;letter-spacing:0.3px;user-select:all;">y7ipei5rw48329n8k0h69jk12zgfyrbva7r5nxucasnollsyo</span>
                    <span id="copy-addy-btn" title="Copy address" style="cursor:pointer;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.10);background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.45);font-size:10px;line-height:1;transition:background 0.15s;">copy</span>
                  </span>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- RIGHT: Miner check + feed -->
      <div class="rightcol">
        <div id="miner-card" class="card">
          <div class="head">
            <h2>Miner Check (by addy)</h2>
            <span style="font-family:var(--mono);font-size:11px;color:rgba(255,255,255,0.40);white-space:nowrap;">connect miner at <span style="color:rgba(255,255,255,0.65);font-weight:700;">173.249.9.217:5333</span></span>
            <div style="display:flex; align-items:center; gap:10px;">
              <div id="miner-collapse-btn" class="collapse-btn" title="Collapse/expand Miner Check">Collapse</div>
            </div>
          </div>

          <div class="body">
            <div class="controls">
              <input id="miner-input" type="text" placeholder="enter miner id / address (exact match to event.miner)"/>
              <button id="miner-btn">Check</button>
              <button id="miner-clear">Clear</button>
            </div>

            <div class="panel">
              <table class="mini-table">
                <tr class="miner-row"><td>miner</td><td id="m-miner">—</td></tr>
                <tr><td>connected (seen)</td><td id="m-connected">—</td></tr>
                <tr><td>shares (acc / rej)</td><td id="m-shares">—</td></tr>
                <tr><td>last_share_height</td><td id="m-last-h">—</td></tr>
                <tr><td>hashrate (window)</td><td id="m-hr">—</td></tr>
                <tr><td>paid_total (persist)</td><td id="m-paid">—</td></tr>
                <tr><td>last_payout_amount</td><td id="m-last-pay-amt">—</td></tr>
                <tr><td>last_payout_height</td><td id="m-last-pay-h">—</td></tr>
                <tr><td>last_payout_time</td><td id="m-last-pay-ts">—</td></tr>
                <tr><td>share_rate (1m/15m/24h)</td><td id="m-rate">—</td></tr>
                <tr><td>est_hashrate (1m/15m/24h)</td><td id="m-hr3">—</td></tr>
              </table>
              <div class="muted" style="margin-top: 10px;">
                Hashrate uses fixed diff 65536 and share timing based on browser receive-time.
              </div>
            </div>

            <div class="picker" id="miner-picker" style="display:none;"></div>
          </div>
        </div>

        <div id="feed-card" class="card">
          <div class="head">
            <h2>Live Event Feed</h2>
            <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
              <div id="feed-all" class="chip on">All</div>
              <div id="feed-shares" class="chip">Shares</div>
              <div id="feed-blocks" class="chip">Blocks</div>
              <div id="feed-payouts" class="chip">Payouts</div>
              <div id="feed-miner-only" class="chip" title="Show only events for the current Miner Check addy">Miner</div>
              <div class="hint">last 200 events</div>
            </div>
          </div>
          <div class="body">
            <div id="feed" class="feed"></div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
(() => {
  // -------------------------------------------------------------------------
  // Config
  // -------------------------------------------------------------------------
  const SHARE_DIFF = 65536;

  const COIN_DECIMALS = 8;
  const COIN_SYMBOL  = "SNAP";
  const COIN_DIVISOR = Math.pow(10, COIN_DECIMALS);

  const LS_KEY = "snap_pool_dashboard_v1";
  const MAX_SEEN_KEYS = 2048;

  const MAX_HR_POINTS = 8000;
  const MAX_MINER_PAYOUT_KEYS = 2500;

  const BLOCKS_MODE_1D = "1d";
  const BLOCKS_MODE_7D = "7d";
  const BLOCKS_MODE_30D = "30d";

  const HR_MODE_1H = "1h";
  const HR_MODE_6H = "6h";
  const HR_MODE_24H = "24h";

  const SNAPSHOT_POLL_MS = 5000;

  const UI_KEY = "snap_pool_dashboard_ui_v1";

  const FEED_MODE_ALL = "all";
  const FEED_MODE_SHARES = "shares";
  const FEED_MODE_BLOCKS = "blocks";
  const FEED_MODE_PAYOUTS = "payouts";

  const EXPLORER_TX_BASE = "https://explorer.snap-coin.net/tx/";
  const EXPLORER_BLOCK_BASE = "https://explorer.snap-coin.net/block/";

  const SNAPSHOT_URL = "/api/snapshot";

  // -------------------------------------------------------------------------
  // State
  // -------------------------------------------------------------------------
  const state = {
    connected: false,
    lastEvtMs: 0,

    minersActive: new Set(),
    sharesAccepted: 0,
    sharesRejected: 0,
    blocksFound: 0,

    lastPayoutHeight: null,
    lastPayoutMinersPaid: null,
    lastPayoutTotalReward: null,
    lastPayoutPoolFee: null,
    lastPayoutMinersNetAtomic: null,
    totalPaidToMinersAtomic: "0",

    minerPaidTotals: {},
    minerLastPayout: {},

    blocksByDay: {},
    blocksByHour: {},

    seenPayoutKeys: new Set(),
    seenBlockKeys: new Set(),

    miners: new Map(),

    net: {
      hashrate_hs: null,
      difficulty: null,
      height: null,
      reward: null,
      last_hash: null,
      last_block_secs_ago: null,
      avg_block_time_secs: null,
      last_update_ms: 0,
    },

    blocksMode: BLOCKS_MODE_7D,

    // Pool hashrate series from snapshot.timeseries.pool_hashrate_1m_24h
    hrSeries: [],
    // Network hashrate series from snapshot.timeseries.network_hashrate_1m_24h
    netHrSeries: [],
    hrMode: HR_MODE_6H,

    minerCollapsed: true,

    feedMode: FEED_MODE_ALL,
    feedMinerOnly: false,
    feedEvents: [],

    replayingSnapshot: false,
    initialSnapshotApplied: false,

    chartsRaf: 0,
    chartsDirtyBlocks: true,
    chartsDirtyHr: true,
  };

  // -------------------------------------------------------------------------
  // DOM helpers
  // -------------------------------------------------------------------------
  const el = (id) => document.getElementById(id);

  const statusDot = el("status-dot");
  const statusText = el("status-text");
  const lastEvt = el("last-evt");

  const kpiMiners = el("kpi-miners");
  const kpiEff = el("kpi-eff");
  const kpiAcc = el("kpi-acc");
  const kpiRej = el("kpi-rej");
  const kpiBlocks = el("kpi-blocks");

  const mPoolHr = el("m-pool-hr");
  const mNetHr = el("m-net-hr");
  const mSharePct = el("m-share-pct");

  const snapLastPayout = el("snap-last-payout");
  const snapLastPayoutMiners = el("snap-last-payout-miners");
  const snapLastPayoutTotal = el("snap-last-payout-total");
  const snapLastPayoutNet = el("snap-last-payout-net");
  const snapLastPayoutFee = el("snap-last-payout-fee");
  const snapTotalPaidMiners = el("snap-total-paid-miners");

  const netHeight = el("net-height");
  const netHashrate = el("net-hashrate");
  const netDifficulty = el("net-difficulty");
  const netReward = el("net-reward");
  const netLastAge = el("net-last-age");
  const netAvgBt = el("net-avg-bt");
  const netLastHash = el("net-last-hash");

  const feed = el("feed");

  const minerCard = el("miner-card");
  const minerCollapseBtn = el("miner-collapse-btn");
  const minerInput = el("miner-input");
  const minerBtn = el("miner-btn");
  const minerClear = el("miner-clear");
  const minerPicker = el("miner-picker");

  const mMiner = el("m-miner");
  const mConnected = el("m-connected");
  const mShares = el("m-shares");
  const mLastH = el("m-last-h");
  const mHR = el("m-hr");
  const mPaid = el("m-paid");
  const mLastPayAmt = el("m-last-pay-amt");
  const mLastPayH = el("m-last-pay-h");
  const mLastPayTs = el("m-last-pay-ts");
  const mRate = el("m-rate");
  const mHR3 = el("m-hr3");

  const blocks1d = el("blocks-1d");
  const blocks7d = el("blocks-7d");
  const blocks30d = el("blocks-30d");
  const blocksChartTitle = el("blocks-chart-title");
  const blocksChart = el("blocks-chart");
  const blocksChartCtx = blocksChart.getContext("2d");

  const hr1h = el("hr-1h");
  const hr6h = el("hr-6h");
  const hr24h = el("hr-24h");
  const hrChartTitle = el("hr-chart-title");
  const hrChart = el("hashrate-chart");
  const hrChartCtx = hrChart.getContext("2d");

  const feedAll = el("feed-all");
  const feedShares = el("feed-shares");
  const feedBlocks = el("feed-blocks");
  const feedPayouts = el("feed-payouts");
  const feedMinerOnly = el("feed-miner-only");

  // -------------------------------------------------------------------------
  // Small helpers
  // -------------------------------------------------------------------------
  function escapeHtml(s){
    return String(s ?? "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }
  function explorerTxUrl(txid){ const t=String(txid??"").trim(); if(!t) return ""; return EXPLORER_TX_BASE+encodeURIComponent(t); }
  function explorerBlockUrl(hash){ const h=String(hash??"").trim(); if(!h) return ""; return EXPLORER_BLOCK_BASE+encodeURIComponent(h); }
  function explorerLink(url,label){ const u=String(url??"").trim(); if(!u) return escapeHtml(label); return `<a class="explink" href="${escapeHtml(u)}" target="_blank" rel="noopener">${escapeHtml(label)}</a>`; }
  function minerSpan(minerId,extraClass){ const m=String(minerId??"").trim(); const cls=extraClass?`minerlink ${extraClass}`:"minerlink"; return `<span class="${cls}" data-miner="${escapeHtml(m)}">${escapeHtml(m)}</span>`; }
  function pick(obj,keys){ if(!obj||typeof obj!=="object") return undefined; for(const k of keys){ if(obj[k]!==undefined&&obj[k]!==null) return obj[k]; } return undefined; }
  function formatDifficulty(num){ if(!num||!isFinite(num)||num<=0) return "—"; return num.toLocaleString(); }

  // -------------------------------------------------------------------------
  // Chart scheduling
  // -------------------------------------------------------------------------
  function markChartsDirty(which){
    if(which==="blocks") state.chartsDirtyBlocks=true;
    if(which==="hr") state.chartsDirtyHr=true;
    if(which==="all"){ state.chartsDirtyBlocks=true; state.chartsDirtyHr=true; }
    scheduleCharts();
  }
  function scheduleCharts(){
    if(state.chartsRaf) return;
    state.chartsRaf=requestAnimationFrame(()=>{
      state.chartsRaf=0;
      if(state.chartsDirtyBlocks){ state.chartsDirtyBlocks=false; drawBlocksChart(); }
      if(state.chartsDirtyHr){ state.chartsDirtyHr=false; drawHashrateChart(); }
    });
  }

  // -------------------------------------------------------------------------
  // Timeseries loader helper
  // -------------------------------------------------------------------------
  function loadTimeseriesArray(tsArr){
    if(!Array.isArray(tsArr)||tsArr.length<2) return null;
    const nowMs=Date.now();
    const keepT=nowMs-(48*3600*1000);
    const pts=tsArr
      .map(p=>{ const tSec=(p&&p.t!==undefined&&p.t!==null)?Number(p.t):NaN; const v=(p&&p.v!==undefined&&p.v!==null)?Number(p.v):NaN; if(!isFinite(tSec)||!isFinite(v)) return null; return {t:Math.floor(tSec*1000),v}; })
      .filter(p=>p&&isFinite(p.t)&&isFinite(p.v))
      .filter(p=>p.t>=keepT&&p.t<=nowMs)
      .sort((a,b)=>a.t-b.t);
    return (pts.length>=2)?pts.slice(-MAX_HR_POINTS):null;
  }

  // -------------------------------------------------------------------------
  // applySnapshot
  // -------------------------------------------------------------------------
  function applySnapshot(snap){
    if(!snap||typeof snap!=="object") return;

    const totals=snap.totals||null;
    if(totals&&typeof totals==="object"){
      if(totals.shares_acc!==undefined&&isFinite(Number(totals.shares_acc))) state.sharesAccepted=Number(totals.shares_acc);
      if(totals.shares_rej!==undefined&&isFinite(Number(totals.shares_rej))) state.sharesRejected=Number(totals.shares_rej);
      if(totals.blocks_found!==undefined&&isFinite(Number(totals.blocks_found))) state.blocksFound=Number(totals.blocks_found);
      if(totals.total_paid_to_miners!==undefined&&totals.total_paid_to_miners!==null) state.totalPaidToMinersAtomic=String(totals.total_paid_to_miners);
    }

    const net=pick(snap,["net","network","network_stats","networkStats"])||snap;
    const payout=pick(snap,["payout","last_payout","lastPayout","payout_summary","payoutSummary"])||snap;

    const n_hashrate=pick(net,["hashrate_hs","hashrateHs","network_hashrate_hs"]);
    const n_diff=pick(net,["difficulty","network_difficulty"]);
    const n_height=pick(net,["height","network_height"]);
    const n_reward=pick(net,["reward","block_reward"]);
    const n_lastHash=pick(net,["last_hash","lastHash"]);
    const n_age=pick(net,["last_block_secs_ago","lastBlockSecsAgo"]);
    const n_avgBt=pick(net,["avg_block_time_secs","avgBlockTimeSecs"]);

    if(n_hashrate!==undefined&&isFinite(Number(n_hashrate))) state.net.hashrate_hs=Number(n_hashrate);
    if(n_diff!==undefined&&isFinite(Number(n_diff))) state.net.difficulty=Number(n_diff);
    if(n_height!==undefined&&isFinite(Number(n_height))) state.net.height=Number(n_height);
    if(n_reward!==undefined) state.net.reward=n_reward;
    if(n_lastHash!==undefined) state.net.last_hash=String(n_lastHash);
    if(n_age!==undefined&&isFinite(Number(n_age))) state.net.last_block_secs_ago=Number(n_age);
    if(n_avgBt!==undefined&&isFinite(Number(n_avgBt))) state.net.avg_block_time_secs=Number(n_avgBt);
    state.net.last_update_ms=Date.now();

    const lp_h=pick(payout,["last_payout_height","lastPayoutHeight","height"]);
    const lp_mp=pick(payout,["last_payout_miners_paid","lastPayoutMinersPaid","miners_paid","minersPaid"]);
    const lp_tot=pick(payout,["last_payout_total_reward","lastPayoutTotalReward","total_reward","totalReward"]);
    const lp_fee=pick(payout,["last_payout_pool_fee","lastPayoutPoolFee","pool_fee","poolFee"]);

    if(lp_h!==undefined&&isFinite(Number(lp_h))) state.lastPayoutHeight=Number(lp_h);
    if(lp_mp!==undefined&&isFinite(Number(lp_mp))) state.lastPayoutMinersPaid=Number(lp_mp);
    if(lp_tot!==undefined) state.lastPayoutTotalReward=lp_tot;
    if(lp_fee!==undefined) state.lastPayoutPoolFee=lp_fee;

    const elDiff=document.getElementById("snap-pool-diff-fixed");
    if(elDiff){ const diffNum=Number(snap.pool_difficulty_fixed_num); elDiff.textContent=(diffNum>0)?formatDifficulty(diffNum):"—"; elDiff.title=snap.pool_difficulty_fixed||""; }

    const paidT=pick(snap,["totalPaidToMinersAtomic","total_paid_to_miners_atomic","total_paid_to_miners"]);
    if(paidT!==undefined&&paidT!==null) state.totalPaidToMinersAtomic=String(paidT);

    const mPaidTotals=pick(snap,["minerPaidTotals","miner_paid_totals"]);
    const mLastPayout2=pick(snap,["minerLastPayout","miner_last_payout"]);
    if(mPaidTotals&&typeof mPaidTotals==="object") state.minerPaidTotals=mPaidTotals;
    if(mLastPayout2&&typeof mLastPayout2==="object") state.minerLastPayout=mLastPayout2;

    const sa=pick(snap,["sharesAccepted","shares_accepted"]);
    const sr=pick(snap,["sharesRejected","shares_rejected"]);
    const bf=pick(snap,["blocksFound","blocks_found"]);
    if(sa!==undefined&&isFinite(Number(sa))) state.sharesAccepted=Number(sa);
    if(sr!==undefined&&isFinite(Number(sr))) state.sharesRejected=Number(sr);
    if(bf!==undefined&&isFinite(Number(bf))) state.blocksFound=Number(bf);

    // ── Timeseries load ──
    const tsRoot=(snap.timeseries&&typeof snap.timeseries==="object")?snap.timeseries:null;

    // Pool hashrate
    const tsPool=tsRoot?(tsRoot.pool_hashrate_1m_24h||tsRoot.hashrate_1m_24h||tsRoot.hashrate1m24h||null):null;
    const poolPts=loadTimeseriesArray(tsPool);
    if(poolPts){ state.hrSeries=poolPts; markChartsDirty("hr"); }

    // Network hashrate
    const tsNet=tsRoot?(tsRoot.network_hashrate_1m_24h||null):null;
    const netPts=loadTimeseriesArray(tsNet);
    if(netPts){ state.netHrSeries=netPts; markChartsDirty("hr"); }

    savePersisted();

    // Load daily_buckets
    const buckets=snap.daily_buckets||snap.dailyBuckets||[];
    if(Array.isArray(buckets)){
      for(const b of buckets){
        if(!b||!b.date) continue;
        if(b.blocks!==undefined&&isFinite(Number(b.blocks))) state.blocksByDay[String(b.date)]=Number(b.blocks);
      }
    }

    // Hourly buckets
    (function loadBlocksHourlyFromSnapshot(){
      const ts=(tsRoot&&Array.isArray(tsRoot.blocks_1d))?tsRoot.blocks_1d:null;
      if(!Array.isArray(ts)||ts.length===0) return;
      const pts=ts.map(p=>{ const t=(p&&p.t!==undefined)?Number(p.t):NaN; const v=(p&&p.v!==undefined)?Number(p.v):NaN; if(!isFinite(t)||!isFinite(v)) return null; return {t,v}; }).filter(p=>p).sort((a,b)=>a.t-b.t);
      if(pts.length===0) return;
      const take=Math.min(24,pts.length);
      const tail=pts.slice(pts.length-take).map(p=>Math.max(0,Math.floor(p.v)));
      const vals=[]; const pad=24-tail.length;
      for(let i=0;i<pad;i++) vals.push(0);
      for(const v of tail) vals.push(v);
      const out={};
      for(let i=23,idx=0;i>=0;i--,idx++){ out[hourKeyFromNowHours(i)]=Number(vals[idx]||0); }
      state.blocksByHour=out;
      pruneBlocksByHour();
      markChartsDirty("blocks");
    })();

    updateKpis();

    const cur=(minerInput.value||"").trim();
    if(cur) setMinerView(cur);

    // Replay feed ONLY on first snapshot
    if(!state.initialSnapshotApplied){
      const merged=[];
      const reUnified=snap.recent_events||snap.recentEvents||null;
      if(Array.isArray(reUnified)&&reUnified.length) for(const e of reUnified) merged.push(e);
      const reShares=snap.recent_shares||snap.recentShares||null;
      const reBlocks=snap.recent_blocks||snap.recentBlocks||null;
      const rePayouts=snap.recent_payouts||snap.recentPayouts||null;
      if(Array.isArray(reShares)&&reShares.length) for(const e of reShares) merged.push(e);
      if(Array.isArray(reBlocks)&&reBlocks.length) for(const e of reBlocks) merged.push(e);
      if(Array.isArray(rePayouts)&&rePayouts.length) for(const e of rePayouts) merged.push(e);

      if(merged.length){
        merged.sort((a,b)=>{ const ta=Number((a&&a.timestamp)?a.timestamp:0); const tb=Number((b&&b.timestamp)?b.timestamp:0); return ta-tb; });
        state.replayingSnapshot=true;
        state.feedEvents=[];
        for(const evt of merged){
          if(!evt||!evt.type) continue;
          const origTs=evt.timestamp?evt.timestamp*1000:Date.now();
          const savedNow=Date.now;
          Date.now=()=>origTs;
          try{ ingestEvent(evt); } finally { Date.now=savedNow; }
        }
        state.replayingSnapshot=false;
        savePersisted();
        updateKpis();
        renderFeed();
        refreshMinerPicker();
      }
      state.initialSnapshotApplied=true;
      markChartsDirty("all");
    }
  }

  async function fetchSnapshot(){
    const host=window.location.host;
    if(!host) return;
    try{
      const res=await fetch(SNAPSHOT_URL,{cache:"no-store"});
      if(!res||!res.ok) return;
      const snap=await res.json();
      applySnapshot(snap);
    } catch {}
  }

  // -------------------------------------------------------------------------
  // Persistence helpers
  // -------------------------------------------------------------------------
  function safeJsonParse(s){ try{ return JSON.parse(s); } catch { return null; } }

  function loadUiPrefs(){
    const raw=localStorage.getItem(UI_KEY);
    const obj=raw?safeJsonParse(raw):null;
    if(obj&&typeof obj==="object"){ if(typeof obj.minerCollapsed==="boolean") state.minerCollapsed=obj.minerCollapsed; }
  }
  function saveUiPrefs(){ try{ localStorage.setItem(UI_KEY,JSON.stringify({minerCollapsed:state.minerCollapsed})); } catch {} }

  function loadPersisted(){
    const raw=localStorage.getItem(LS_KEY);
    if(!raw) return;
    const obj=safeJsonParse(raw);
    if(!obj||typeof obj!=="object") return;

    if(typeof obj.sharesAccepted==="number") state.sharesAccepted=obj.sharesAccepted;
    if(typeof obj.sharesRejected==="number") state.sharesRejected=obj.sharesRejected;
    if(typeof obj.blocksFound==="number") state.blocksFound=obj.blocksFound;
    if(typeof obj.lastPayoutHeight==="number") state.lastPayoutHeight=obj.lastPayoutHeight;
    if(typeof obj.lastPayoutMinersPaid==="number") state.lastPayoutMinersPaid=obj.lastPayoutMinersPaid;
    if(obj.lastPayoutTotalReward!==undefined&&obj.lastPayoutTotalReward!==null) state.lastPayoutTotalReward=obj.lastPayoutTotalReward;
    if(obj.lastPayoutPoolFee!==undefined&&obj.lastPayoutPoolFee!==null) state.lastPayoutPoolFee=obj.lastPayoutPoolFee;
    if(obj.lastPayoutMinersNetAtomic!==undefined&&obj.lastPayoutMinersNetAtomic!==null) state.lastPayoutMinersNetAtomic=String(obj.lastPayoutMinersNetAtomic);
    if(typeof obj.totalPaidToMinersAtomic==="string") state.totalPaidToMinersAtomic=obj.totalPaidToMinersAtomic;
    if(obj.minerPaidTotals&&typeof obj.minerPaidTotals==="object") state.minerPaidTotals=obj.minerPaidTotals;
    if(obj.minerLastPayout&&typeof obj.minerLastPayout==="object") state.minerLastPayout=obj.minerLastPayout;
    if(obj.blocksByDay&&typeof obj.blocksByDay==="object") state.blocksByDay=obj.blocksByDay;
    if(obj.blocksByHour&&typeof obj.blocksByHour==="object") state.blocksByHour=obj.blocksByHour;
    if(Array.isArray(obj.seenPayoutKeys)) state.seenPayoutKeys=new Set(obj.seenPayoutKeys.slice(-MAX_SEEN_KEYS));
    if(Array.isArray(obj.seenBlockKeys)) state.seenBlockKeys=new Set(obj.seenBlockKeys.slice(-MAX_SEEN_KEYS));
    if([BLOCKS_MODE_1D,BLOCKS_MODE_7D,BLOCKS_MODE_30D].includes(obj.blocksMode)) state.blocksMode=obj.blocksMode;
    if(Array.isArray(obj.hrSeries)) state.hrSeries=obj.hrSeries.filter(p=>p&&typeof p.t==="number"&&typeof p.v==="number"&&isFinite(p.t)&&isFinite(p.v)).slice(-MAX_HR_POINTS);
    if(Array.isArray(obj.netHrSeries)) state.netHrSeries=obj.netHrSeries.filter(p=>p&&typeof p.t==="number"&&typeof p.v==="number"&&isFinite(p.t)&&isFinite(p.v)).slice(-MAX_HR_POINTS);
    if([HR_MODE_1H,HR_MODE_6H,HR_MODE_24H].includes(obj.hrMode)) state.hrMode=obj.hrMode;
  }

  function savePersisted(){
    const minerKeys=Object.keys(state.minerPaidTotals||{});
    if(minerKeys.length>MAX_MINER_PAYOUT_KEYS){
      const scored=minerKeys.map(k=>{ const lp=state.minerLastPayout[k]; return {k,ts:(lp&&typeof lp.ts==="number")?lp.ts:0}; }).sort((a,b)=>a.ts-b.ts);
      const dropN=scored.length-MAX_MINER_PAYOUT_KEYS;
      for(let i=0;i<dropN;i++){ delete state.minerPaidTotals[scored[i].k]; delete state.minerLastPayout[scored[i].k]; }
    }

    const payload={
      sharesAccepted:state.sharesAccepted, sharesRejected:state.sharesRejected, blocksFound:state.blocksFound,
      lastPayoutHeight:state.lastPayoutHeight, lastPayoutMinersPaid:state.lastPayoutMinersPaid,
      lastPayoutTotalReward:state.lastPayoutTotalReward, lastPayoutPoolFee:state.lastPayoutPoolFee,
      lastPayoutMinersNetAtomic:state.lastPayoutMinersNetAtomic,
      totalPaidToMinersAtomic:state.totalPaidToMinersAtomic,
      minerPaidTotals:state.minerPaidTotals, minerLastPayout:state.minerLastPayout,
      blocksByDay:state.blocksByDay, blocksByHour:state.blocksByHour,
      seenPayoutKeys:Array.from(state.seenPayoutKeys).slice(-MAX_SEEN_KEYS),
      seenBlockKeys:Array.from(state.seenBlockKeys).slice(-MAX_SEEN_KEYS),
      blocksMode:state.blocksMode,
      hrSeries:state.hrSeries.slice(-MAX_HR_POINTS),
      netHrSeries:state.netHrSeries.slice(-MAX_HR_POINTS),
      hrMode:state.hrMode,
    };
    try{ localStorage.setItem(LS_KEY,JSON.stringify(payload)); } catch {}
  }

  // -------------------------------------------------------------------------
  // Formatting + math
  // -------------------------------------------------------------------------
  function fmtTime(ms){ if(!ms) return "—"; return new Date(ms).toLocaleTimeString(); }
  function fmtUnixSec(sec){ if(!sec) return "—"; return new Date(sec*1000).toLocaleTimeString(); }
  function fmtU128Like(v){ if(v===null||v===undefined) return "—"; try{ return String(v).replace(/\B(?=(\d{3})+(?!\d))/g,","); } catch { return String(v); } }
  function fmtHashTrunc(s){ const v=String(s||"").trim(); if(!v||v==="unknown") return "—"; if(v.length<=16) return v; return v.slice(0,8)+"…"+v.slice(-8); }

  function fmtAgeSeconds(sec){
    if(sec===null||sec===undefined) return "—";
    const v=Number(sec); if(!isFinite(v)||v<0) return "—";
    if(v<60) return `${Math.floor(v)}s`;
    if(v<3600) return `${Math.floor(v/60)}m ${Math.floor(v%60)}s`;
    return `${Math.floor(v/3600)}h ${Math.floor((v%3600)/60)}m`;
  }

  function fmtReward(v){
    if(v===null||v===undefined) return "—";
    try{
      const raw=BigInt(String(v)); const divisor=BigInt(COIN_DIVISOR);
      const whole=raw/divisor; const frac=raw%divisor;
      let fracStr=frac.toString().padStart(COIN_DECIMALS,"0").replace(/0+$/,"");
      return fracStr.length===0?`${whole.toLocaleString()} ${COIN_SYMBOL}`:`${whole.toLocaleString()}.${fracStr} ${COIN_SYMBOL}`;
    } catch { return String(v); }
  }

  function rewardNetAtomic(total,fee){
    if(total===null||total===undefined||fee===null||fee===undefined) return null;
    try{ const t=BigInt(String(total)); const f=BigInt(String(fee)); const n=t-f; return (n>=0n)?n:null; } catch { return null; }
  }

  function sumPayoutsAtomic(payouts){
    if(!Array.isArray(payouts)||payouts.length===0) return null;
    try{ let sum=0n; for(const p of payouts){ if(!p||p.amount===null||p.amount===undefined) continue; sum+=BigInt(String(p.amount)); } return sum; } catch { return null; }
  }

  function addU128Str(aStr,bStr){
    try{ return String(BigInt(String(aStr||"0"))+BigInt(String(bStr||"0"))); } catch { return String(aStr||"0"); }
  }

  function fmtHashrate(hs){
    if(hs===null||hs===undefined) return "—";
    const v=Number(hs); if(!isFinite(v)||v<0) return "—";
    if(v>=1e12) return (v/1e12).toFixed(2)+" TH/s";
    if(v>=1e9) return (v/1e9).toFixed(2)+" GH/s";
    if(v>=1e6) return (v/1e6).toFixed(2)+" MH/s";
    if(v>=1e3) return (v/1e3).toFixed(2)+" KH/s";
    return v.toFixed(2)+" H/s";
  }

  function countWithinWindowMs(timesMs,windowSec){
    const now=Date.now(); const cutoff=now-(windowSec*1000);
    let c=0; for(let i=timesMs.length-1;i>=0;i--){ if(timesMs[i]>=cutoff) c++; else break; } return c;
  }
  function ratePerSec(count,windowSec){ return windowSec<=0?0:count/windowSec; }

  function dayKey(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
  function dayKeyFromNow(daysAgo){ const d=new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate()-daysAgo); return dayKey(d); }
  function todayKey(){ return dayKeyFromNow(0); }
  function hourKey(d){ return `${dayKey(d)}T${String(d.getHours()).padStart(2,"0")}`; }
  function hourKeyFromNowHours(hoursAgo){ const d=new Date(); d.setMinutes(0,0,0); d.setHours(d.getHours()-hoursAgo); return hourKey(d); }

  function pruneBlocksByDay(){
    const keep=new Set(); for(let i=0;i<45;i++) keep.add(dayKeyFromNow(i));
    const out={}; for(const k of Object.keys(state.blocksByDay||{})){ if(keep.has(k)) out[k]=state.blocksByDay[k]; }
    state.blocksByDay=out;
  }
  function pruneBlocksByHour(){
    const keep=new Set(); for(let i=0;i<72;i++) keep.add(hourKeyFromNowHours(i));
    const out={}; for(const k of Object.keys(state.blocksByHour||{})){ if(keep.has(k)) out[k]=state.blocksByHour[k]; }
    state.blocksByHour=out;
  }

  function getLatestFromSeries(series){
    const pts=series||[];
    if(!Array.isArray(pts)||pts.length===0) return null;
    const last=pts[pts.length-1];
    return (last&&isFinite(last.v))?last.v:null;
  }

  // -------------------------------------------------------------------------
  // Miner aggregation
  // -------------------------------------------------------------------------
  function pushTs(arr,ms){ arr.push(ms); if(arr.length>300) arr.splice(0,arr.length-300); }
  function computeHashrateFromTs(arr){
    if(!arr||arr.length<2) return null;
    const n=Math.min(arr.length,20); if(n<2) return null;
    const slice=arr.slice(arr.length-n);
    const dt=(slice[slice.length-1]-slice[0])/1000.0; if(dt<=0) return null;
    return ((slice.length-1)/dt)*SHARE_DIFF;
  }
  function ensureMiner(minerId){
    if(!state.miners.has(minerId)) state.miners.set(minerId,{connectedSeen:false,ip:null,acc:0,rej:0,lastHeight:null,workTotal:"0",lastSeenMs:0,shareTimesMs:[]});
    return state.miners.get(minerId);
  }
  function refreshMinerPicker(){
    const ids=Array.from(state.miners.keys()).sort();
    if(ids.length===0){ minerPicker.style.display="none"; minerPicker.innerHTML=""; return; }
    minerPicker.style.display="flex"; minerPicker.innerHTML="";
    for(const id of ids){
      const chip=document.createElement("div"); chip.className="chip"; chip.textContent=id; chip.title="Click to fill + check";
      chip.addEventListener("click",()=>{ minerInput.value=id; setMinerView(id); renderFeed(); });
      minerPicker.appendChild(chip);
    }
  }

  // -------------------------------------------------------------------------
  // Feed
  // -------------------------------------------------------------------------
  const FEED_MAX=2000;
  function pushFeedEvent(e){ state.feedEvents.unshift(e); if(state.feedEvents.length>FEED_MAX) state.feedEvents.splice(FEED_MAX); if(!state.replayingSnapshot) renderFeed(); }
  function feedModeMatches(cat){ return state.feedMode===FEED_MODE_ALL||cat===state.feedMode; }
  function feedMinerMatches(minersArr){
    if(!state.feedMinerOnly) return true;
    const cur=(minerInput.value||"").trim(); if(!cur) return true;
    return Array.isArray(minersArr)&&minersArr.includes(cur);
  }
  function renderFeed(){
    feed.innerHTML="";
    for(const e of state.feedEvents){
      if(!feedModeMatches(e.cat)) continue;
      if(!feedMinerMatches(e.miners)) continue;
      const d=document.createElement("div"); d.className="evt "+e.typeClass;
      const t=new Date(e.tsMs).toLocaleTimeString();
      d.innerHTML=`<span class="t">[${t}]</span><span class="tag">${e.tag}</span> ${e.html}`;
      feed.appendChild(d);
    }
  }
  function updateFeedChips(){
    feedAll.classList.toggle("on",state.feedMode===FEED_MODE_ALL);
    feedShares.classList.toggle("on",state.feedMode===FEED_MODE_SHARES);
    feedBlocks.classList.toggle("on",state.feedMode===FEED_MODE_BLOCKS);
    feedPayouts.classList.toggle("on",state.feedMode===FEED_MODE_PAYOUTS);
    feedMinerOnly.classList.toggle("on",!!state.feedMinerOnly);
  }

  // -------------------------------------------------------------------------
  // UI updates
  // -------------------------------------------------------------------------
  function setConnected(ok){
    state.connected=ok;
    statusDot.className="dot "+(ok?"ok":"bad");
    statusText.textContent=ok?"Connected ✓":"Disconnected ✗ (retrying)";
  }

  function updateNetUi(){
    const n=state.net;
    netHeight.textContent=(n.height===null||n.height===undefined)?"—":fmtU128Like(n.height);
    netHashrate.textContent=fmtHashrate(n.hashrate_hs);
    netDifficulty.textContent=(n.difficulty===null||n.difficulty===undefined)?"—":fmtU128Like(n.difficulty);
    netReward.textContent=fmtReward(n.reward);
    netLastAge.textContent=fmtAgeSeconds(n.last_block_secs_ago);
    netAvgBt.textContent=fmtAgeSeconds(n.avg_block_time_secs);
    netLastHash.textContent=fmtHashTrunc(n.last_hash);
  }

  function updateBlocksChips(){
    blocks1d.classList.toggle("on",state.blocksMode===BLOCKS_MODE_1D);
    blocks7d.classList.toggle("on",state.blocksMode===BLOCKS_MODE_7D);
    blocks30d.classList.toggle("on",state.blocksMode===BLOCKS_MODE_30D);
    if(state.blocksMode===BLOCKS_MODE_1D) blocksChartTitle.textContent="Blocks per hour (24h)";
    else if(state.blocksMode===BLOCKS_MODE_7D) blocksChartTitle.textContent="Blocks per day (7d)";
    else blocksChartTitle.textContent="Blocks per day (30d)";
  }

  function updateHrChips(){
    hr1h.classList.toggle("on",state.hrMode===HR_MODE_1H);
    hr6h.classList.toggle("on",state.hrMode===HR_MODE_6H);
    hr24h.classList.toggle("on",state.hrMode===HR_MODE_24H);
  }

  function drawBarChart(ctx,canvas,labels,values,opts){
    const rect=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
    const w=Math.max(420,Math.floor(rect.width)); const h=Math.max(110,Math.floor(rect.height));
    if(canvas.width!==Math.floor(w*dpr)||canvas.height!==Math.floor(h*dpr)){ canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); }
    ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,w,h);
    ctx.strokeStyle="rgba(255,255,255,0.06)"; ctx.lineWidth=1;
    for(let i=1;i<=3;i++){ const y=Math.floor((h*i)/4); ctx.beginPath(); ctx.moveTo(10,y); ctx.lineTo(w-10,y); ctx.stroke(); }
    const maxV=Math.max(1,...values.map(v=>Number(v)||0));
    const padL=10,padR=10,padT=10,padB=22,innerW=w-padL-padR,innerH=h-padT-padB;
    const n=labels.length; const barGap=(n<=24)?4:3; const barW=Math.max(2,Math.floor((innerW-(n-1)*barGap)/n));
    for(let i=0;i<n;i++){
      const v=Number(values[i]||0); const bh=Math.floor((v/maxV)*innerH); const x=padL+i*(barW+barGap); const y=padT+(innerH-bh);
      ctx.fillStyle="rgba(111,231,255,0.35)"; ctx.fillRect(x,y,barW,bh);
      const showTick=(opts&&typeof opts.tickEvery==="number")?(i===0||i===n-1||(i%opts.tickEvery===0)):(i===0||i===n-1);
      if(showTick){ ctx.fillStyle="rgba(255,255,255,0.45)"; ctx.font="10px "+CSS.supports("font-family","ui-monospace")?"ui-monospace":"monospace"; ctx.font="10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace"; ctx.fillText(labels[i],x,h-6); }
    }
    ctx.fillStyle="rgba(255,255,255,0.55)"; ctx.font="10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace"; ctx.fillText(`max=${maxV}`,w-62,12);
  }

  function drawBlocksChart(){
    if(state.blocksMode===BLOCKS_MODE_1D){
      const labels=[],values=[];
      for(let i=23;i>=0;i--){ const k=hourKeyFromNowHours(i); labels.push(k.slice(-2)); values.push(Number(state.blocksByHour[k]||0)); }
      drawBarChart(blocksChartCtx,blocksChart,labels,values,{tickEvery:3}); return;
    }
    const days=(state.blocksMode===BLOCKS_MODE_7D)?7:30; const labels=[],values=[];
    for(let i=days-1;i>=0;i--){ const k=dayKeyFromNow(i); labels.push(k.slice(5)); values.push(Number(state.blocksByDay[k]||0)); }
    drawBarChart(blocksChartCtx,blocksChart,labels,values,{tickEvery:(days===7)?1:7});
  }

  // -------------------------------------------------------------------------
  // Hashrate chart — dual axis (pool green left, network cyan right)
  // -------------------------------------------------------------------------
  function drawHashrateChart(){
    const rect=hrChart.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
    const w=Math.max(420,Math.floor(rect.width)); const h=Math.max(160,Math.floor(rect.height));
    if(hrChart.width!==Math.floor(w*dpr)||hrChart.height!==Math.floor(h*dpr)){ hrChart.width=Math.floor(w*dpr); hrChart.height=Math.floor(h*dpr); }
    hrChartCtx.setTransform(dpr,0,0,dpr,0,0); hrChartCtx.clearRect(0,0,w,h);

    const font="10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";

    // Grid
    hrChartCtx.strokeStyle="rgba(255,255,255,0.06)"; hrChartCtx.lineWidth=1;
    for(let i=1;i<=4;i++){ const y=Math.floor((h*i)/5); hrChartCtx.beginPath(); hrChartCtx.moveTo(10,y); hrChartCtx.lineTo(w-10,y); hrChartCtx.stroke(); }

    const now=Date.now();
    let windowMs=6*3600*1000;
    if(state.hrMode===HR_MODE_1H) windowMs=1*3600*1000;
    if(state.hrMode===HR_MODE_24H) windowMs=24*3600*1000;
    const t0=now-windowMs;

    if(state.hrMode===HR_MODE_1H) hrChartTitle.textContent="Hashrate (last 1h)";
    else if(state.hrMode===HR_MODE_6H) hrChartTitle.textContent="Hashrate (last 6h)";
    else hrChartTitle.textContent="Hashrate (last 24h)";

    const poolPts=(state.hrSeries||[]).filter(p=>p.t>=t0&&p.t<=now);
    const netPts=(state.netHrSeries||[]).filter(p=>p.t>=t0&&p.t<=now);

    if(poolPts.length<2&&netPts.length<2){
      hrChartCtx.fillStyle="rgba(255,255,255,0.55)"; hrChartCtx.font="12px "+font.slice(5);
      hrChartCtx.fillText("No series yet (waiting for backend timeseries)",14,22);
      return;
    }

    function quantile(sorted,q){
      const n=sorted.length; if(n===0) return NaN; if(n===1) return sorted[0];
      const pos=(n-1)*q; const lo=Math.floor(pos); const hi=Math.ceil(pos);
      if(lo===hi) return sorted[lo]; return sorted[lo]*(1-(pos-lo))+sorted[hi]*(pos-lo);
    }

    const padL=10,padR=10,padT=14,padB=22;
    const innerW=w-padL-padR,innerH=h-padT-padB;
    function xFor(t){ return padL+((t-t0)/windowMs)*innerW; }

    // ── Pool scale (left axis) ──
    let poolMax=1,poolPeak=0;
    if(poolPts.length>=2){
      const poolValsAll=poolPts.map(p=>p.v).filter(v=>isFinite(v));
      const poolValsNZ=poolValsAll.filter(v=>v>0);
      const sv=(poolValsNZ.length>=2)?poolValsNZ:poolValsAll;
      const sorted=sv.slice().sort((a,b)=>a-b);
      const p95=quantile(sorted,0.95);
      poolMax=Math.max(1,p95*1.15);
      poolPeak=poolValsAll.length?Math.max(...poolValsAll):0;
    }
    function yPool(v){ const vv=Math.min(v,poolMax); return padT+(1-vv/poolMax)*innerH; }

    // ── Network scale (right axis) ──
    let netMin=0,netMax=1,netRange=1;
    if(netPts.length>=2){
      const netVals=netPts.map(p=>p.v).filter(v=>isFinite(v)).sort((a,b)=>a-b);
      if(netVals.length>=2){
        netMin=Math.max(0,netVals[0]*0.95);
        netMax=netVals[netVals.length-1]*1.05;
        netRange=(netMax-netMin)||1;
      }
    }
    function yNet(v){ return padT+(1-(v-netMin)/netRange)*innerH; }

    // ── Draw network (behind pool) ──
    if(netPts.length>=2){
      // Dashed line
      hrChartCtx.strokeStyle="rgba(111,231,255,0.50)"; hrChartCtx.lineWidth=1.5;
      hrChartCtx.setLineDash([4,3]);
      hrChartCtx.beginPath();
      for(let i=0;i<netPts.length;i++){
        const x=xFor(netPts[i].t),y=yNet(netPts[i].v);
        if(i===0) hrChartCtx.moveTo(x,y); else hrChartCtx.lineTo(x,y);
      }
      hrChartCtx.stroke();
      hrChartCtx.setLineDash([]);

      // Fill
      hrChartCtx.beginPath();
      for(let i=0;i<netPts.length;i++){
        const x=xFor(netPts[i].t),y=yNet(netPts[i].v);
        if(i===0) hrChartCtx.moveTo(x,y); else hrChartCtx.lineTo(x,y);
      }
      hrChartCtx.lineTo(xFor(netPts[netPts.length-1].t),padT+innerH);
      hrChartCtx.lineTo(xFor(netPts[0].t),padT+innerH);
      hrChartCtx.closePath();
      hrChartCtx.fillStyle="rgba(111,231,255,0.04)";
      hrChartCtx.fill();

      // Right axis ticks (cyan)
      hrChartCtx.font=font; hrChartCtx.fillStyle="rgba(111,231,255,0.35)";
      for(let i=0;i<=3;i++){
        const v=netMin+(netRange*i/3); const y=yNet(v);
        const lbl=fmtHashrate(v);
        hrChartCtx.fillText(lbl,w-padR-hrChartCtx.measureText(lbl).width,y-3);
      }
    }

    // ── Draw pool (on top) ──
    if(poolPts.length>=2){
      // Line
      hrChartCtx.strokeStyle="rgba(76,255,155,0.75)"; hrChartCtx.lineWidth=2;
      hrChartCtx.beginPath();
      for(let i=0;i<poolPts.length;i++){
        const x=xFor(poolPts[i].t),y=yPool(poolPts[i].v);
        if(i===0) hrChartCtx.moveTo(x,y); else hrChartCtx.lineTo(x,y);
      }
      hrChartCtx.stroke();

      // Fill
      hrChartCtx.lineTo(xFor(poolPts[poolPts.length-1].t),padT+innerH);
      hrChartCtx.lineTo(xFor(poolPts[0].t),padT+innerH);
      hrChartCtx.closePath();
      hrChartCtx.fillStyle="rgba(76,255,155,0.10)";
      hrChartCtx.fill();
    }

    // ── Labels ──
    hrChartCtx.font=font;

    // Left: pool scale
    if(poolPts.length>=2){
      hrChartCtx.fillStyle="rgba(140,218,174,0.7)";
      hrChartCtx.fillText(`pool_max(p95)=${fmtHashrate(poolMax)}`,12,12);
      const peakStr=`peak=${fmtHashrate(poolPeak)}`;
      hrChartCtx.fillStyle="rgba(255,255,255,0.45)";
      hrChartCtx.fillText(peakStr,Math.max(12,w-12-hrChartCtx.measureText(peakStr).width),26);
    }

    // Right: net scale
    if(netPts.length>=2){
      const netMedian=netPts[Math.floor(netPts.length/2)].v;
      const netLabel=`net: ~${fmtHashrate(netMedian)}`;
      hrChartCtx.fillStyle="rgba(111,231,255,0.7)";
      hrChartCtx.fillText(netLabel,w-12-hrChartCtx.measureText(netLabel).width,12);
    }

    // Time labels
    hrChartCtx.fillStyle="rgba(255,255,255,0.40)"; hrChartCtx.font=font;
    const tickCount=6;
    for(let i=0;i<=tickCount;i++){
      const t=t0+((now-t0)*i/tickCount); const x=xFor(t);
      const lbl=new Date(t).toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"});
      hrChartCtx.fillText(lbl,x-14,h-6);
    }
  }

  // -------------------------------------------------------------------------
  // KPIs update
  // -------------------------------------------------------------------------
  function updateKpis(){
    kpiMiners.textContent=String(state.minersActive.size);
    kpiAcc.textContent=String(state.sharesAccepted);
    kpiRej.textContent=String(state.sharesRejected);
    kpiBlocks.textContent=String(state.blocksFound);

    // Pool Efficiency
    const totalShares=state.sharesAccepted+state.sharesRejected;
    if(totalShares>0){
      const eff=(state.sharesAccepted/totalShares)*100;
      kpiEff.textContent=eff.toFixed(1)+"%";
      kpiEff.className="value "+(eff>=99?"accent-green":eff>=95?"accent-orange":"accent-red");
    } else {
      kpiEff.textContent="—";
      kpiEff.className="value accent-green";
    }

    // Inline metric pills
    const poolHr=getLatestFromSeries(state.hrSeries);
    const netHr=getLatestFromSeries(state.netHrSeries);
    mPoolHr.textContent=fmtHashrate(poolHr);
    mNetHr.textContent=fmtHashrate(netHr);

    if(poolHr!==null&&netHr!==null&&netHr>0){
      const pct=(poolHr/netHr)*100;
      mSharePct.textContent=pct.toFixed(1)+"%";
    } else {
      mSharePct.textContent="—";
    }

    snapLastPayout.textContent=state.lastPayoutHeight??"—";
    snapLastPayoutTotal.textContent=fmtReward(state.lastPayoutTotalReward);
    snapLastPayoutFee.textContent=fmtReward(state.lastPayoutPoolFee);

    let netAtomic=null;
    if(state.lastPayoutMinersNetAtomic!==null&&state.lastPayoutMinersNetAtomic!==undefined){
      try{ netAtomic=BigInt(String(state.lastPayoutMinersNetAtomic)); } catch { netAtomic=null; }
    }
    if(netAtomic===null) netAtomic=rewardNetAtomic(state.lastPayoutTotalReward,state.lastPayoutPoolFee);
    snapLastPayoutNet.textContent=(netAtomic===null)?"—":fmtReward(String(netAtomic));
    snapLastPayoutMiners.textContent=(state.lastPayoutMinersPaid===null||state.lastPayoutMinersPaid===undefined)?"—":String(state.lastPayoutMinersPaid);
    snapTotalPaidMiners.textContent=fmtReward(state.totalPaidToMinersAtomic);

    updateNetUi();
    updateBlocksChips();
    updateHrChips();
    updateFeedChips();
  }

  function setMinerView(minerId){
    let id=(minerId||"").trim();
    if(id&&!id.startsWith("Public:")) id="Public: "+id;
    if(!id){ mMiner.textContent="—"; mConnected.textContent="—"; mShares.textContent="—"; mLastH.textContent="—"; mHR.textContent="—"; mPaid.textContent="—"; mLastPayAmt.textContent="—"; mLastPayH.textContent="—"; mLastPayTs.textContent="—"; mRate.textContent="—"; mHR3.textContent="—"; return; }
    const m=state.miners.get(id);
    if(!m){ mMiner.textContent=id; mConnected.textContent="no (not seen)"; mShares.textContent="0 / 0"; mLastH.textContent="—"; mHR.textContent="—"; }
    else { mMiner.textContent=id; mConnected.textContent=m.connectedSeen?"yes":"no"; mShares.textContent=`${m.acc} / ${m.rej}`; mLastH.textContent=(m.lastHeight!==null&&m.lastHeight!==undefined)?String(m.lastHeight):"—"; mHR.textContent=fmtHashrate(computeHashrateFromTs(m.shareTimesMs)); }
    const paidStr=(state.minerPaidTotals&&state.minerPaidTotals[id])?state.minerPaidTotals[id]:"0";
    mPaid.textContent=fmtReward(paidStr);
    const lp=(state.minerLastPayout&&state.minerLastPayout[id])?state.minerLastPayout[id]:null;
    if(lp){ mLastPayAmt.textContent=fmtReward(lp.amount); mLastPayH.textContent=(lp.height===null||lp.height===undefined)?"—":String(lp.height); mLastPayTs.textContent=fmtUnixSec(lp.ts); }
    else { mLastPayAmt.textContent="—"; mLastPayH.textContent="—"; mLastPayTs.textContent="—"; }
    const times=(m&&Array.isArray(m.shareTimesMs))?m.shareTimesMs:[];
    const c1=countWithinWindowMs(times,60),c15=countWithinWindowMs(times,15*60),c24=countWithinWindowMs(times,24*60*60);
    mRate.textContent=`${c1}/1m  ${c15}/15m  ${c24}/24h`;
    const h1=ratePerSec(c1,60)*SHARE_DIFF,h15=ratePerSec(c15,15*60)*SHARE_DIFF,h24=ratePerSec(c24,24*60*60)*SHARE_DIFF;
    mHR3.textContent=`${fmtHashrate(h1)}  ${fmtHashrate(h15)}  ${fmtHashrate(h24)}`;
  }

  // -------------------------------------------------------------------------
  // Dedupe + persisted counters
  // -------------------------------------------------------------------------
  function addSeenKey(setObj,key){
    if(setObj.has(key)) return false; setObj.add(key);
    if(setObj.size>MAX_SEEN_KEYS){ const arr=Array.from(setObj); const trimmed=arr.slice(arr.length-MAX_SEEN_KEYS); setObj.clear(); for(const k of trimmed) setObj.add(k); }
    return true;
  }
  function bumpBlocksToday(){ const k=todayKey(); if(!state.blocksByDay[k]) state.blocksByDay[k]=0; state.blocksByDay[k]+=1; pruneBlocksByDay(); }
  function bumpBlocksThisHour(){ const d=new Date(); d.setMinutes(0,0,0); const k=hourKey(d); if(!state.blocksByHour[k]) state.blocksByHour[k]=0; state.blocksByHour[k]+=1; pruneBlocksByHour(); }

  function applyMinerCollapsed(){
    minerCard.classList.toggle("collapsed",!!state.minerCollapsed);
    minerCollapseBtn.textContent=state.minerCollapsed?"Expand":"Collapse";
    setTimeout(()=>markChartsDirty("all"),0);
  }

  // -------------------------------------------------------------------------
  // Event ingestion
  // -------------------------------------------------------------------------
  function ingestEvent(ev){
    state.lastEvtMs=Date.now();
    lastEvt.textContent=fmtTime(state.lastEvtMs);
    const replay=state.replayingSnapshot;

    switch(ev.type){
      case "snapshot": applySnapshot(ev.data); break;

      case "MinerConnected": {
        const miner=String(ev.miner??"").trim(); const ip=String(ev.ip??"").trim();
        if(miner){ state.minersActive.add(miner); const m=ensureMiner(miner); m.connectedSeen=true; m.ip=ip||m.ip; m.lastSeenMs=Date.now(); }
        pushFeedEvent({tsMs:Date.now(),typeClass:"miner",cat:FEED_MODE_ALL,tag:"Miner",html:`Connected: ${minerSpan(miner,"accent-cyan")} <span class="t">ip=${escapeHtml(ip||"?")}</span>`,miners:miner?[miner]:[]});
        if(!replay) refreshMinerPicker(); break;
      }

      case "MinerDisconnected": {
        const miner=String(ev.miner??"").trim();
        if(miner){ state.minersActive.delete(miner); ensureMiner(miner).lastSeenMs=Date.now(); }
        pushFeedEvent({tsMs:Date.now(),typeClass:"miner",cat:FEED_MODE_ALL,tag:"Miner",html:`Disconnected: ${minerSpan(miner,"accent-red")}`,miners:miner?[miner]:[]});
        if(!replay) refreshMinerPicker(); break;
      }

      case "ShareAccepted": {
        const nowMs=Date.now(); const miner=String(ev.miner??"").trim();
        const height=(ev.height!==undefined&&ev.height!==null)?Number(ev.height):null;
        const workUnits=ev.work_units; const workTotal=ev.work_total;
        if(!replay){ state.sharesAccepted+=1; savePersisted(); }
        if(miner){
          state.minersActive.add(miner); const m=ensureMiner(miner);
          m.connectedSeen=true; if(!replay) m.acc+=1; m.lastHeight=height??m.lastHeight; m.lastSeenMs=nowMs; if(!replay) pushTs(m.shareTimesMs,nowMs);
          if(workTotal!==undefined&&workTotal!==null) m.workTotal=String(workTotal);
          else if(workUnits!==undefined&&workUnits!==null){ try{ m.workTotal=String(BigInt(m.workTotal)+BigInt(String(workUnits))); } catch {} }
        }
        pushFeedEvent({tsMs:Date.now(),typeClass:"share",cat:FEED_MODE_SHARES,tag:"Share",html:`Accepted: ${minerSpan(miner,"accent-green")} <span class="t">h=${escapeHtml(height??"?")}</span> <span class="t">work=${escapeHtml(fmtU128Like(workUnits??"—"))}</span>`,miners:miner?[miner]:[]});
        if(!replay){ let cur=(minerInput.value||"").trim(); if(cur&&!cur.startsWith("Public:")) cur="Public: "+cur; if(cur===miner) setMinerView(miner); }
        break;
      }

      case "ShareRejected": {
        const miner=String(ev.miner??"").trim(); const reason=String(ev.reason??"").trim();
        if(!replay){ state.sharesRejected+=1; savePersisted(); }
        if(miner){ const m=ensureMiner(miner); m.connectedSeen=true; if(!replay) m.rej+=1; m.lastSeenMs=Date.now(); }
        pushFeedEvent({tsMs:Date.now(),typeClass:"reject",cat:FEED_MODE_SHARES,tag:"Reject",html:`${minerSpan(miner,"accent-red")} <span class="t">${escapeHtml(reason||"")}</span>`,miners:miner?[miner]:[]});
        if(!replay) refreshMinerPicker(); break;
      }

      case "BlockFound": {
        const height=(ev.height!==undefined&&ev.height!==null)?Number(ev.height):null;
        const reward=(ev.reward!==undefined&&ev.reward!==null)?ev.reward:null;
        let bh=String(ev.hash??"").trim();
        const match=bh.match(/Hash:\s*([^)]+)/); if(match&&match[1]) bh=match[1].trim();
        if(bh.startsWith("Hash:")) bh=bh.replace(/^Hash:\s*/,"");
        const bhUrl=explorerBlockUrl(bh); const bhLink=bh?explorerLink(bhUrl,bh):"—";
        const blockKey=`block:${height??"?"}`;
        if(!replay){ const isNew=addSeenKey(state.seenBlockKeys,blockKey); if(isNew){ state.blocksFound+=1; bumpBlocksToday(); bumpBlocksThisHour(); savePersisted(); markChartsDirty("blocks"); } }
        pushFeedEvent({tsMs:Date.now(),typeClass:"block",cat:FEED_MODE_BLOCKS,tag:"BLOCK",html:`Found: <span class="accent-yellow">height=${escapeHtml(height??"?")}</span> <span class="t">hash=${bhLink}</span> <span class="t">reward=${escapeHtml(fmtReward(reward))}</span>`,miners:[]});
        break;
      }

      case "PayoutComplete": {
        const height=(ev.height!==undefined&&ev.height!==null)?Number(ev.height):null;
        const minersPaid=(ev.miners_paid!==undefined&&ev.miners_paid!==null)?Number(ev.miners_paid):null;
        const totalReward=(ev.total_reward!==undefined&&ev.total_reward!==null)?ev.total_reward:null;
        const poolFee=(ev.pool_fee!==undefined&&ev.pool_fee!==null)?ev.pool_fee:null;
        const payouts=Array.isArray(ev.payouts)?ev.payouts:null;
        const minersNetFromPayouts=sumPayoutsAtomic(payouts);
        let txid=String(ev.txid??"").trim(); if(txid.startsWith("Hash:")) txid=txid.replace(/^Hash:\s*/,"");
        const txUrl=explorerTxUrl(txid); const txLink=txid?explorerLink(txUrl,txid):"";
        const payoutKey=`payout:${height??"?"}:${String(totalReward??"—")}:${String(poolFee??"—")}:${String(minersPaid??"—")}`;

        if(!replay){
          const isNew=addSeenKey(state.seenPayoutKeys,payoutKey);
          state.lastPayoutHeight=height??state.lastPayoutHeight; state.lastPayoutMinersPaid=minersPaid??state.lastPayoutMinersPaid;
          state.lastPayoutTotalReward=totalReward??state.lastPayoutTotalReward; state.lastPayoutPoolFee=poolFee??state.lastPayoutPoolFee;
          state.lastPayoutMinersNetAtomic=(minersNetFromPayouts!==null)?String(minersNetFromPayouts):null;
          if(isNew){
            if(minersNetFromPayouts!==null){
              state.totalPaidToMinersAtomic=addU128Str(state.totalPaidToMinersAtomic,String(minersNetFromPayouts));
              for(const p of payouts||[]){ if(!p) continue; const miner=String(p.miner??"").trim(); if(!miner) continue; const amt=String(p.amount??"0"); state.minerPaidTotals[miner]=addU128Str(state.minerPaidTotals[miner]||"0",amt); state.minerLastPayout[miner]={amount:amt,height:height??null,ts:(ev.timestamp??null)}; }
            } else { const net=rewardNetAtomic(totalReward,poolFee); if(net!==null) state.totalPaidToMinersAtomic=addU128Str(state.totalPaidToMinersAtomic,String(net)); }
          }
          savePersisted();
        }

        const netShown=(minersNetFromPayouts!==null)?fmtReward(String(minersNetFromPayouts)):((rewardNetAtomic(totalReward,poolFee)===null)?"—":fmtReward(String(rewardNetAtomic(totalReward,poolFee))));
        pushFeedEvent({tsMs:Date.now(),typeClass:"payout",cat:FEED_MODE_PAYOUTS,tag:"Payout",html:`Complete: <span class="accent-cyan">block=${escapeHtml(height??"?")}</span> <span class="t">miners=${escapeHtml(minersPaid??"?")}</span> <span class="t">total=${escapeHtml(fmtReward(totalReward))}</span> <span class="t">net=${escapeHtml(netShown)}</span> <span class="t">fee=${escapeHtml(fmtReward(poolFee))}</span>`+(txid?` <span class="t">tx=${txLink}</span>`:``),miners:[]});

        if(Array.isArray(payouts)&&payouts.length){
          for(const p of payouts){
            if(!p) continue; const miner=String(p.miner??"").trim(); if(!miner) continue; const amt=String(p.amount??"0");
            pushFeedEvent({tsMs:Date.now(),typeClass:"minerpay",cat:FEED_MODE_PAYOUTS,tag:"Paid",html:`${minerSpan(miner,"accent-magenta")} <span class="t">amt=${escapeHtml(fmtReward(amt))}</span> <span class="t">h=${escapeHtml(height??"?")}</span>`+(txid?` <span class="t">tx=${txLink}</span>`:``),miners:[miner]});
          }
        }
        break;
      }

      case "NetworkStats": {
        const hashrate=(ev.hashrate_hs!==undefined&&ev.hashrate_hs!==null)?Number(ev.hashrate_hs):null;
        const difficulty=(ev.difficulty!==undefined&&ev.difficulty!==null)?Number(ev.difficulty):null;
        const height=(ev.height!==undefined&&ev.height!==null)?Number(ev.height):null;
        const reward=(ev.reward!==undefined&&ev.reward!==null)?ev.reward:null;
        const lastHash=String(ev.last_hash??"").trim();
        const age=(ev.last_block_secs_ago!==undefined&&ev.last_block_secs_ago!==null)?Number(ev.last_block_secs_ago):null;
        const avgBt=(ev.avg_block_time_secs!==undefined&&ev.avg_block_time_secs!==null)?Number(ev.avg_block_time_secs):null;
        state.net.hashrate_hs=isFinite(hashrate)?hashrate:state.net.hashrate_hs;
        state.net.difficulty=isFinite(difficulty)?difficulty:state.net.difficulty;
        state.net.height=isFinite(height)?height:state.net.height;
        state.net.reward=reward??state.net.reward;
        state.net.last_hash=lastHash||state.net.last_hash;
        state.net.last_block_secs_ago=isFinite(age)?age:state.net.last_block_secs_ago;
        state.net.avg_block_time_secs=isFinite(avgBt)?avgBt:state.net.avg_block_time_secs;
        state.net.last_update_ms=Date.now();
        break;
      }

      case "connected": {
        pushFeedEvent({tsMs:Date.now(),typeClass:"miner",cat:FEED_MODE_ALL,tag:"System",html:`<span class="accent-cyan">${escapeHtml(ev.message??"WS connected")}</span>`,miners:[]});
        break;
      }

      default: break;
    }

    if(!replay){ updateKpis(); const cur=(minerInput.value||"").trim(); if(cur) setMinerView(cur); }
  }

  // -------------------------------------------------------------------------
  // WebSocket
  // -------------------------------------------------------------------------
  function connectWs(){
    const host=window.location.host;
    if(!host){ setConnected(false); pushFeedEvent({tsMs:Date.now(),typeClass:"reject",cat:FEED_MODE_ALL,tag:"System",html:"Opened as file:// — open via http://&lt;host&gt;:&lt;port&gt;/",miners:[]}); return; }
    const proto=(window.location.protocol==="https:")?"wss://":"ws://";
    let ws;
    try{ ws=new WebSocket(`${proto}${host}/ws`); } catch(e){ setConnected(false); pushFeedEvent({tsMs:Date.now(),typeClass:"reject",cat:FEED_MODE_ALL,tag:"System",html:`WebSocket init failed: ${escapeHtml(String(e))}`,miners:[]}); setTimeout(connectWs,2500); return; }
    ws.onopen=()=>{ setConnected(true); fetchSnapshot(); };
    ws.onclose=()=>{ setConnected(false); setTimeout(connectWs,2000); };
    ws.onerror=()=>{ setConnected(false); };
    ws.onmessage=(msg)=>{ try{ ingestEvent(JSON.parse(msg.data)); } catch {} };
  }

  // -------------------------------------------------------------------------
  // Controls
  // -------------------------------------------------------------------------
  minerBtn.addEventListener("click",()=>{ setMinerView((minerInput.value||"").trim()); renderFeed(); });
  minerInput.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ setMinerView((minerInput.value||"").trim()); renderFeed(); } });
  minerClear.addEventListener("click",()=>{ minerInput.value=""; setMinerView(""); renderFeed(); });
  minerCollapseBtn.addEventListener("click",()=>{ state.minerCollapsed=!state.minerCollapsed; saveUiPrefs(); applyMinerCollapsed(); });

  feed.addEventListener("click",(e)=>{
    const t=e.target&&e.target.closest?e.target.closest(".minerlink"):null; if(!t) return;
    const miner=String(t.getAttribute("data-miner")||"").trim(); if(!miner) return;
    minerInput.value=miner;
    if(state.minerCollapsed){ state.minerCollapsed=false; saveUiPrefs(); applyMinerCollapsed(); }
    setMinerView(miner); renderFeed();
  });

  blocks1d.addEventListener("click",()=>{ state.blocksMode=BLOCKS_MODE_1D; savePersisted(); updateKpis(); markChartsDirty("blocks"); });
  blocks7d.addEventListener("click",()=>{ state.blocksMode=BLOCKS_MODE_7D; savePersisted(); updateKpis(); markChartsDirty("blocks"); });
  blocks30d.addEventListener("click",()=>{ state.blocksMode=BLOCKS_MODE_30D; savePersisted(); updateKpis(); markChartsDirty("blocks"); });

  hr1h.addEventListener("click",()=>{ state.hrMode=HR_MODE_1H; savePersisted(); updateKpis(); markChartsDirty("hr"); });
  hr6h.addEventListener("click",()=>{ state.hrMode=HR_MODE_6H; savePersisted(); updateKpis(); markChartsDirty("hr"); });
  hr24h.addEventListener("click",()=>{ state.hrMode=HR_MODE_24H; savePersisted(); updateKpis(); markChartsDirty("hr"); });

  feedAll.addEventListener("click",()=>{ state.feedMode=FEED_MODE_ALL; updateKpis(); renderFeed(); });
  feedShares.addEventListener("click",()=>{ state.feedMode=FEED_MODE_SHARES; updateKpis(); renderFeed(); });
  feedBlocks.addEventListener("click",()=>{ state.feedMode=FEED_MODE_BLOCKS; updateKpis(); renderFeed(); });
  feedPayouts.addEventListener("click",()=>{ state.feedMode=FEED_MODE_PAYOUTS; updateKpis(); renderFeed(); });
  feedMinerOnly.addEventListener("click",()=>{ state.feedMinerOnly=!state.feedMinerOnly; updateKpis(); renderFeed(); });

  window.addEventListener("resize",()=>markChartsDirty("all"));

  // Copy donate address
  document.getElementById("copy-addy-btn").addEventListener("click",function(){
    const addy=document.getElementById("donate-addy").textContent;
    navigator.clipboard.writeText(addy).then(()=>{
      this.textContent="copied!"; this.style.color="var(--green)";
      setTimeout(()=>{ this.textContent="copy"; this.style.color="rgba(255,255,255,0.55)"; },1500);
    }).catch(()=>{
      const r=document.createRange(); r.selectNodeContents(document.getElementById("donate-addy"));
      const s=window.getSelection(); s.removeAllRanges(); s.addRange(r);
      this.textContent="selected"; setTimeout(()=>{ this.textContent="copy"; },1500);
    });
  });

  // -------------------------------------------------------------------------
  // Boot
  // -------------------------------------------------------------------------
  loadUiPrefs();
  loadPersisted();
  pruneBlocksByDay();
  pruneBlocksByHour();
  setConnected(false);
  setMinerView("");
  applyMinerCollapsed();
  updateKpis();
  renderFeed();
  fetchSnapshot();
  setInterval(()=>{ fetchSnapshot(); updateKpis(); },SNAPSHOT_POLL_MS);
  markChartsDirty("all");
  connectWs();
})();
</script>

</body>
</html>
<!-- =========================================================================
File: pool_dashboard.html
Location: snap-coin-pool/static/pool_dashboard.html
Version: 1.6.0-dual-hashrate.1
Created: 2026-02-15T21:15:00Z
========================================================================  -->